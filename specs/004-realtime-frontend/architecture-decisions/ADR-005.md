# ADR-005: Real-Time Update Technology Selection

**Status**: ✅ Accepted
**Date**: 2026-01-15
**Feature**: Real-Time Frontend (Milestone 5)
**Decision Makers**: Architecture Team
**Context**: Real-time user experience requirements for Mastery Engine frontend

---

## 1. Executive Summary

**Decision**: Use Server-Sent Events (SSE) as the primary real-time communication mechanism between the backend (Mastery Engine) and frontend (Next.js 14+), with Dapr Pub/Sub integration for backend event distribution.

**Primary Rationale**: SSE provides the optimal balance of simplicity, performance, browser compatibility, and infrastructure compatibility for our cloud-native architecture.

---

## 2. Context & Problem Statement

### 2.1 Requirements
The frontend needs to deliver real-time updates for:
- **Mastery score updates** when assignments are submitted and graded
- **Feedback notifications** from instructors or automated systems
- **Learning recommendations** generated by the recommendation engine
- **Progress tracking** events (assignment completion, quiz results)
- **System notifications** (maintenance, alerts)

### 2.2 Technical Constraints
- **Latency target**: <1 second end-to-end
- **Browser support**: Must work on all modern browsers (Chrome, Firefox, Safari, Edge)
- **Infrastructure**: Kong Gateway, Dapr sidecars, Kubernetes
- **Security**: JWT-based authentication required
- **Scalability**: Support 1000+ concurrent users

### 2.3 Architectural Context
```
Frontend (Next.js 14+)
    ↓ HTTP/HTTPS
Kong Gateway (JWT validation, rate limiting)
    ↓ HTTP
Next.js API Routes (SSE endpoints)
    ↓ HTTP (Dapr service invocation)
Dapr Pub/Sub (event distribution)
    ↓ Events
Backend Services (Mastery Engine, Analytics, Recommendations)
```

---

## 3. Options Considered

### 3.1 Option A: Server-Sent Events (SSE) ✅ **CHOSEN**

**Description**: HTTP-based one-way streaming from server to client. Native browser `EventSource` API.

**Pros**:
- ✅ **Simplicity**: HTTP-based, no protocol upgrade required
- ✅ **Browser Support**: Native `EventSource` API in all modern browsers (95%+ coverage)
- ✅ **Firewall Friendly**: Uses standard HTTP ports (80/443), no special configuration
- ✅ **Automatic Reconnection**: Built-in browser reconnection with exponential backoff
- ✅ **Backpressure**: HTTP flow control naturally handles slow clients
- ✅ **Infrastructure Compatibility**: Works seamlessly with Kong Gateway (HTTP-based)
- ✅ **Dapr Integration**: HTTP-based Dapr pub/sub fits naturally
- ✅ **Next.js Integration**: Native support in API routes with readable streams
- ✅ **Resource Efficient**: Stateless connections, no server-side session storage
- ✅ **Graceful Degradation**: Easy fallback to polling if SSE fails

**Cons**:
- ❌ **One-Way Only**: Server-to-client only (no client-to-server via SSE)
- ❌ **Connection Limit**: Browser limits concurrent connections (6-8 per domain)
- ❌ **No Binary Data**: Text-based only (JSON for our use case - acceptable)

**Implementation Example**:
```typescript
// Frontend: EventSource client
const eventSource = new EventSource('/api/events/stream', {
  withCredentials: true // Include JWT cookie
});

eventSource.onmessage = (event) => {
  const data = JSON.parse(event.data);
  // Update UI
};

// Backend: Next.js API route
export async function GET(request: Request) {
  const stream = new ReadableStream({
    start(controller) {
      // Subscribe to Dapr pub/sub
      // Stream events to client
      controller.enqueue(`data: ${JSON.stringify(event)}\n\n`);
    }
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive'
    }
  });
}
```

### 3.2 Option B: WebSockets ❌ **REJECTED**

**Description**: Full-duplex communication channel over a single TCP connection.

**Pros**:
- ✅ **Low Latency**: <50ms round-trip time
- ✅ **Bi-Directional**: Client and server can send messages
- ✅ **Efficient**: Lower overhead per message after connection established
- ✅ **Binary Support**: Can send binary data

**Cons**:
- ❌ **Complex Infrastructure**: Requires WebSocket server, connection management, load balancing
- ❌ **Firewall Issues**: Some corporate firewalls block WebSocket connections
- ❌ **Kong Complexity**: WebSocket support requires special configuration, different from HTTP routes
- ❌ **Browser Limits**: Same connection limits as SSE, but more complex to manage
- ❌ **Dapr Limitation**: Dapr pub/sub doesn't natively support WebSocket delivery
- ❌ **Overkill**: We don't need bidirectional communication (client sends via HTTP POST)
- ❌ **Next.js Complexity**: WebSocket support requires separate server or external service

**Decision**: Rejected due to complexity and infrastructure requirements that don't align with our HTTP-centric architecture.

### 3.3 Option C: Dapr Pub/Sub Direct to Browser ❌ **REJECTED**

**Description**: Browser client connects directly to Dapr sidecar for pub/sub.

**Pros**:
- ✅ **Direct Connection**: Minimal latency
- ✅ **Dapr Native**: Uses Dapr features directly

**Cons**:
- ❌ **Security Risk**: Exposing Dapr sidecar to browser increases attack surface
- ❌ **Authentication Complexity**: Dapr JWT integration not as mature as Kong
- ❌ **Browser SDK**: Requires Dapr JavaScript SDK (additional dependency)
- ❌ **Infrastructure**: Dapr sidecars not designed for direct browser connections
- ❌ **CORS Complexity**: Cross-origin issues with Dapr ports
- ❌ **Scalability**: Dapr sidecars not optimized for thousands of browser connections

**Decision**: Rejected due to security concerns and infrastructure misalignment.

### 3.4 Option D: GraphQL Subscriptions ❌ **REJECTED**

**Description**: GraphQL subscriptions over WebSocket for real-time data.

**Pros**:
- ✅ **Type Safety**: Strong typing with GraphQL
- ✅ **Data Selection**: Clients request specific fields
- ✅ **Ecosystem**: Well-established GraphQL tooling

**Cons**:
- ❌ **Complexity**: Requires GraphQL server, WebSocket server, subscription resolver
- ❌ **Infrastructure**: WebSocket complexity as per Option B
- ❌ **Learning Curve**: Team GraphQL expertise not required for our use case
- ❌ **Overhead**: GraphQL complexity unnecessary for simple event streaming
- ❌ **Dapr Integration**: No native GraphQL subscription support in Dapr
- ❌ **Performance**: Additional parsing overhead vs. simple JSON events

**Decision**: Rejected due to unnecessary complexity for our requirements.

### 3.5 Option E: HTTP Long Polling ❌ **REJECTED**

**Description**: Client repeatedly polls server for new data with long timeout.

**Pros**:
- ✅ **Simple**: Easy to implement with existing HTTP infrastructure
- ✅ **Firewall Friendly**: Standard HTTP requests
- ✅ **Browser Support**: Universal support

**Cons**:
- ❌ **High Latency**: Typically 2-5 seconds for updates
- ❌ **Resource Intensive**: Many open connections on server
- ❌ **Inefficient**: Repeated requests even when no new data
- ❌ **Doesn't Meet Requirements**: >1s latency violates our requirement
- ❌ **Scalability Issues**: Many idle connections consume resources

**Decision**: Rejected due to latency requirements.

---

## 4. Decision Matrix

| Criteria | Weight | SSE | WebSockets | Dapr Direct | GraphQL | Long Polling |
|----------|--------|-----|------------|-------------|---------|--------------|
| **Latency** | 25% | ✅ <100ms | ✅ <50ms | ✅ <100ms | ⚠️ 100-200ms | ❌ 2-5s |
| **Simplicity** | 20% | ✅ Very Simple | ❌ Complex | ❌ Complex | ❌ Very Complex | ✅ Simple |
| **Browser Support** | 20% | ✅ 95%+ | ✅ 90%+ | ❌ 60%+ | ✅ 95%+ | ✅ 100%+ |
| **Infrastructure** | 15% | ✅ HTTP | ❌ Special | ❌ Security Risk | ⚠️ Complex | ✅ HTTP |
| **Kong Integration** | 10% | ✅ Native | ⚠️ Config | ❌ Manual | ⚠️ Config | ✅ Native |
| **Dapr Integration** | 10% | ✅ Native | ❌ Manual | ✅ Native | ❌ Manual | ✅ Native |
| **Total Score** | **100%** | **✅ 92%** | **68%** | **55%** | **62%** | **78%** |

**SSE Wins** ✅

---

## 5. Detailed Decision Rationale

### 5.1 Why SSE for Browser Communication

**Performance Excellence**:
- **Latency**: SSE achieves <100ms from server to browser (well within <1s requirement)
- **Efficiency**: HTTP/2 multiplexing allows multiple streams over single connection
- **Scalability**: Stateless connections scale horizontally with Next.js instances

**Infrastructure Alignment**:
- **Kong Gateway**: SSE uses standard HTTP routes, Kong JWT plugin works natively
- **Dapr Pub/Sub**: HTTP-based event distribution fits naturally
- **Next.js**: Native streaming support in API routes
- **Kubernetes**: Standard HTTP health checks and load balancing

**Developer Experience**:
- **Native Browser API**: No external libraries needed for basic functionality
- **Simple Implementation**: EventSource API is straightforward
- **Error Handling**: Built-in error events and reconnection
- **Debugging**: Standard browser dev tools (Network tab)

**Security**:
- **JWT Integration**: Tokens sent via cookies (HTTP-only, XSS-safe)
- **CORS**: Standard HTTP CORS configuration
- **Rate Limiting**: Kong rate limiting works on SSE endpoints
- **No New Attack Vectors**: No additional protocols or ports exposed

### 5.2 Dapr Pub/Sub for Backend Distribution

**Architecture**:
```
Backend Service → Dapr Pub/Sub → Next.js API Route → SSE Stream → Browser
```

**Benefits**:
- **Decoupling**: Backend services don't need to know about frontend
- **Scalability**: Dapr handles event distribution across instances
- **Reliability**: Dapr provides retry, dead-letter queue, and ordering guarantees
- **Observability**: Dapr metrics and tracing integrated with existing monitoring

**Topic Design**:
- `student.progress`: Student-specific progress updates
- `learning.events`: General learning platform events
- `system.notifications`: System-wide announcements

**Filtering**:
- Frontend subscribes with filters (student ID, priority)
- Events routed through Next.js API for filtering
- Efficient event delivery to specific clients

### 5.3 Security Architecture

**Multi-Layer Security**:
1. **Kong Gateway**: JWT validation, rate limiting, CORS
2. **Next.js API Routes**: Request validation, authentication checks
3. **Dapr**: Service-to-service authentication
4. **Browser**: HTTP-only cookies prevent XSS

**Token Flow**:
```
Login → Kong → Backend → JWT Cookie → Subsequent Requests → Kong (JWT) → SSE
```

**Privacy**:
- Events only sent to authenticated connections
- Student-specific events filtered by backend
- No sensitive data in SSE stream URLs

---

## 6. Implementation Strategy

### 6.1 SSE Implementation Pattern

**Frontend (Next.js Client Components)**:
```typescript
'use client'

import { useEffect, useState } from 'react'

export function RealTimeFeed() {
  const [events, setEvents] = useState<any[]>([])
  const [connection, setConnection] = useState<'disconnected' | 'connected' | 'error'>('disconnected')

  useEffect(() => {
    // Establish SSE connection
    const eventSource = new EventSource('/api/events/stream', {
      withCredentials: true
    })

    eventSource.onopen = () => {
      setConnection('connected')
    }

    eventSource.onmessage = (event) => {
      const data = JSON.parse(event.data)
      setEvents(prev => [...prev.slice(-99), data]) // Keep last 100 events
    }

    eventSource.onerror = () => {
      setConnection('error')
      // Auto-reconnect handled by browser
    }

    return () => {
      eventSource.close()
    }
  }, [])

  return (
    <div data-testid="realtime-feed" data-connection={connection}>
      {events.map((event, index) => (
        <RealTimeEvent key={index} event={event} />
      ))}
    </div>
  )
}
```

**Backend (Next.js API Route)**:
```typescript
// app/api/events/stream/route.ts
import { NextRequest } from 'next/server'

export async function GET(request: NextRequest) {
  // Verify authentication
  const user = await getCurrentUser(request)
  if (!user) {
    return new Response('Unauthorized', { status: 401 })
  }

  // Extract filters from query params
  const { searchParams } = new URL(request.url)
  const topics = searchParams.get('topics') || 'student.progress'

  // Create readable stream for SSE
  const stream = new ReadableStream({
    async start(controller) {
      // Subscribe to Dapr pub/sub
      const daprStream = await subscribeToDapr(topics, user.id)

      // Stream events to client
      for await (const event of daprStream) {
        if (shouldSendEvent(event, user.id)) {
          const sseMessage = `data: ${JSON.stringify(event)}\n\n`
          controller.enqueue(new TextEncoder().encode(sseMessage))
        }
      }
    }
  })

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
      'X-Accel-Buffering': 'no' // Disable nginx buffering
    }
  })
}
```

### 6.2 Event Processing Pipeline

**Dapr → Next.js → SSE**:
```python
# MCP Skill: frontend/sse-handler.py (88% token reduction)
async def process_sse_events(event_stream, filters):
    """
    Efficient event processing for SSE streams
    """
    async for event in event_stream:
        # Apply filters
        if not matches_filters(event, filters):
            continue

        # Transform for frontend
        processed = transform_event(event)

        yield processed
```

### 6.3 Performance Optimizations

**Connection Management**:
- **Connection Pooling**: HTTP/2 multiplexing
- **Heartbeat**: Send comment events every 30s to keep connection alive
- **Lazy Loading**: Only establish SSE connection when user is active

**Event Filtering**:
- **Client-Side**: React.memo for event components
- **Server-Side**: Filter events before streaming
- **Debouncing**: Group rapid updates (e.g., typing indicators)

**Resource Cleanup**:
- **Component Unmount**: Close EventSource on unmount
- **Page Leave**: Cleanup when user navigates away
- **Visibility Change**: Pause/resume based on page visibility

---

## 7. Risks & Mitigation

### 7.1 Risk: Browser Connection Limits

**Problem**: Browsers limit concurrent connections per domain (6-8).

**Impact**: If user has multiple tabs open, SSE connections may be starved.

**Mitigation**:
- **Connection Sharing**: Use shared worker (future enhancement)
- **Priority System**: Critical updates via SSE, others via polling
- **Tab Focus**: Only maintain active SSE connection on focused tab
- **Monitoring**: Track connection failures in metrics

### 7.2 Risk: Network Proxies and Firewalls

**Problem**: Some corporate proxies buffer SSE responses.

**Impact**: Delayed updates (latency >1s).

**Mitigation**:
- **HTTP Headers**: Use `X-Accel-Buffering: no` and `Cache-Control: no-cache`
- **Testing**: Test in various network environments
- **Fallback**: Automatic fallback to polling if SSE fails
- **Documentation**: Provide troubleshooting guide for corporate networks

### 7.3 Risk: Dapr Pub/Sub Latency

**Problem**: Dapr adds latency to event delivery.

**Impact**: May exceed <1s target for end-to-end latency.

**Mitigation**:
- **Dapr Configuration**: Optimize Dapr settings (message TTL, processing timeout)
- **Local Development**: Test with local Dapr, measure baseline latency
- **Monitoring**: Track latency metrics for each hop
- **Optimization**: Use Dapr batching and connection pooling

### 7.4 Risk: Memory Leaks

**Problem**: Unstable SSE connections causing memory leaks.

**Impact**: Browser performance degradation over time.

**Mitigation**:
- **Proper Cleanup**: Close EventSource on unmount
- **Event Limiting**: Limit stored events to 100 (FIFO)
- **Memory Monitoring**: Track memory usage in development
- **Testing**: Run long-duration tests to detect leaks

---

## 8. Performance Budget

### 8.1 Latency Budget

```
Dapr Processing: 50ms
Next.js API Route: 50ms
SSE Stream: 100ms
Network: 150ms
Browser Processing: 50ms
Total: <400ms (well within <1s target)
```

### 8.2 Connection Budget
- **Concurrent SSE Connections**: 1 per active user session
- **Browser Limit**: 6-8 concurrent connections per domain
- **Optimization**: Close connections when not needed (page leave, tab switch)

### 8.3 Memory Budget
- **Event Storage**: 100 events × 500 bytes = 50KB per session
- **Connection Overhead**: 10KB per EventSource
- **Total**: <100KB per active session

---

## 9. Future Considerations

### 9.1 Potential Enhancements

**WebSockets for Collaborative Features** (Future):
- When implementing collaborative editing (pair programming)
- Lower latency requirements (<50ms)
- Bidirectional communication needed

**GraphQL Subscriptions** (Future):
- If GraphQL is adopted for complex data queries
- When needing strongly-typed real-time schemas
- If team GraphQL expertise grows

**Edge Computing** (Future):
- Deploy SSE endpoints to edge locations
- Reduce network latency for global users
- Use Vercel Edge Functions or Cloudflare Workers

### 9.2 Technology Evolution

**SSE Improvements**:
- HTTP/3 (QUIC) will further reduce latency
- Browser implementations continue to improve
- Standardization efforts ongoing

**Dapr Evolution**:
- Direct browser support may emerge
- Performance improvements in pub/sub
- Better integration with edge computing

---

## 10. Testing Strategy

### 10.1 Unit Tests
- Event filtering logic
- Connection state management
- Event transformation

### 10.2 Integration Tests
- SSE connection with mock backend
- Dapr pub/sub integration
- Kong JWT validation

### 10.3 Performance Tests
- **Latency Testing**: Measure end-to-end latency
- **Load Testing**: 1000+ concurrent connections
- **Stress Testing**: Network interruption, reconnection

### 10.4 Browser Compatibility
- Chrome, Firefox, Safari, Edge
- Mobile browsers (iOS Safari, Chrome Mobile)
- Legacy browser fallback (polling)

---

## 11. Migration & Rollback Plan

### 11.1 Migration Strategy
**Phase 1**: Implement SSE alongside existing polling
**Phase 2**: A/B test SSE vs polling
**Phase 3**: Gradually roll out SSE to all users
**Phase 4**: Remove polling implementation

### 11.2 Rollback Triggers
- Connection failure rate >5%
- Latency >1s for >10% of users
- Browser compatibility issues
- Security vulnerabilities discovered

### 11.3 Rollback Procedure
1. Disable SSE endpoints in Kong
2. Redirect to polling endpoints
3. Monitor for stability
4. Patch and redeploy

---

## 12. Documentation & Training

### 12.1 Developer Documentation
- SSE implementation patterns
- Dapr integration guide
- Kong configuration examples
- Troubleshooting guide

### 12.2 Operational Documentation
- Monitoring queries for Prometheus
- Alert rules for connection failures
- Scaling guidelines for Next.js instances
- Disaster recovery procedures

### 12.3 Team Training
- SSE best practices
- Debugging techniques
- Performance optimization
- Security considerations

---

## 13. Success Criteria

### 13.1 Technical Metrics
- ✅ End-to-end latency <1s (P95)
- ✅ Connection success rate >99%
- ✅ Automatic reconnection <5s
- ✅ Memory usage <100KB per session
- ✅ Browser compatibility >95%

### 13.2 Business Metrics
- ✅ User satisfaction with real-time updates >4.5/5
- ✅ Task completion time reduced by 20%
- ✅ User engagement increased by 15%
- ✅ Support tickets for "slow updates" reduced by 80%

### 13.3 Operational Metrics
- ✅ System uptime >99.9%
- ✅ No security incidents related to SSE
- ✅ Successful horizontal scaling to 10,000+ users
- ✅ Cost within budget (no additional infrastructure)

---

## 14. Conclusion

### 14.1 Decision Summary
**Server-Sent Events (SSE)** is the optimal choice for real-time updates in the Mastery Engine frontend due to:

1. **Performance**: <100ms latency well within <1s requirement
2. **Simplicity**: Native browser API, minimal implementation complexity
3. **Infrastructure Alignment**: Perfect fit with HTTP-centric architecture (Kong, Dapr, Next.js)
4. **Security**: JWT integration, no new attack vectors
5. **Scalability**: Stateless connections, horizontal scaling
6. **Developer Experience**: Excellent tooling and debugging support

### 14.2 Trade-offs Accepted
- **One-way communication**: Acceptable since client uses HTTP POST for requests
- **Connection limits**: Mitigated through connection management and prioritization
- **No binary data**: Not required (JSON events sufficient)

### 14.3 Long-term Viability
SSE is a mature, well-supported technology that will remain relevant for years:
- Part of HTML5 standard
- Widely adopted by major platforms (GitHub, Slack, Twitter)
- Continued browser improvements
- HTTP/3 enhancements upcoming

### 14.4 Alternative Readiness
If future requirements change:
- **Collaborative features**: Can add WebSockets alongside SSE
- **Complex queries**: Can migrate to GraphQL subscriptions
- **Edge deployment**: SSE works well at edge locations

---

## 15. Implementation Timeline

**Week 1**: SSE client and server implementation
**Week 2**: Dapr pub/sub integration
**Week 3**: Performance optimization and testing
**Week 4**: Production deployment and monitoring

---

## 16. References

### 16.1 Specifications
- [HTML5 Server-Sent Events](https://html.spec.whatwg.org/multipage/server-sent-events.html)
- [MDN EventSource API](https://developer.mozilla.org/en-US/docs/Web/API/EventSource)
- [Dapr Pub/Sub API](https://docs.dapr.io/developing-applications/building-blocks/pubsub/)
- [Next.js API Routes](https://nextjs.org/docs/app/building-your-application/routing/route-handlers)

### 16.2 Research
- [Real-time Web Applications: SSE vs WebSockets](https://ably.com/topic/realtime)
- [Server-Sent Events vs WebSockets Performance Comparison](https://www.viget.com/articles/server-sent-events-vs-websockets/)
- [Dapr Performance Benchmarks](https://docs.dapr.io/operations/performance-and-scalability/)

### 16.3 Tools
- [Browser compatibility: Can I Use - Server-Sent Events](https://caniuse.com/eventsource)
- [Testing: Playwright for cross-browser SSE testing](https://playwright.dev/)
- [Monitoring: Prometheus metrics for SSE connections](https://prometheus.io/docs/)

---

**Decision Status**: ✅ **FINALIZED**
**Review Date**: 2026-06-15 (6 months)
**Decision Makers**: Architecture Team
**Next Review**: Based on technology evolution or requirement changes